# Translated from section 5.7.3 of http://fsl.cs.uiuc.edu/images/0/0c/CS422-Spring-2010-CHALLENGE.pdf

# Reading from the store
Threads:
  Thread:
    K::
      -VarId: X
      +Value: V
    Env:
      Entry:
        VarId: X
        Location: L
Store:
  Entry:
    Location: L
    Value: V

# Statement Block with variable declaration
K::
  -BlockWithSavedEnv:
    Vars:=
    Body:=
      *:* S
  +*:* S

K::
  -Block: B
  +BlockWithSavedEnv: B
  +RestoreEnvironment: E
Env: E

K::
  -RestoreEnvironment: E
-Env:
+Env: E

Threads:
  Thread:
    K::
      BlockWithSavedEnv:
        Vars:
          -VarId: X
    Env:
      !Entry:
        VarId: X
      +Entry:
        VarId: X
        Location: L
Store:
  +Entry:
    Location: L
    Value:
      Integer: 0
-NextLoc: L
+NextLoc: < L + 1

K::
  BlockWithSavedEnv:
    Vars:
      VarId: X
Env:
  -Entry:
    VarId: X

# Side effects: increment
Threads:
  Thread:
    K::
      -Increment:
        VarId: X
      +Integer: < I + 1
    Env:
      Entry:
        VarId: X
        Location: L
Store:
  Entry:
    Location: L
    Value:
      -Integer: I
      +Integer: < I + 1

# Obtaining the reference location of a name
K::
  -Reference:
    VarId: X
  +Integer: L
Env:
  Entry:
    VarId: X
    Location: L

# Dereferencing a location
Threads:
  Thread:
    K::
      -Dereference:
        Integer: L
      +Value: V
Store:
  Entry:
    Location: L
    Value: V

# Memory allocation (TODO: zero out the store)
Threads:
  Thread:
    K::
      -Malloc:
        Integer: N
      +Integer: L
Ptr:
  +Entry:
    Location: L
    Size: N
-NextLoc: L
+NextLoc: L + N

# Free (TODO: bottom out the store)
Threads:
  Thread:
    K::
      -Free:
        Integer: L
Ptr:
  -Entry:
    Location: L

# Assignment
Threads:
  Thread:
    K::
      -Assignment:
        VarId: X
        Value: V
    Env:
      Entry:
        VarId: X
        Location: L
Store:
  Entry:
    Location: L
    -Value:
    +Value: V

# Dereferencing Assignment
Threads:
  Thread:
    K::
      -Assignment:
        Location: L
        Value: V
Store:
  Entry:
    Location: L
    -Value:
    +Value: V

# Declare aspect
Threads:
  Thread:
    K::
      -Aspect::=
        *:* S
Aspect::=
  -*:*
  +*:* S

# Bind aspect to function
Threads:
  Thread:
    K::
      -LambdaAbstraction:
        Vars: V
        Body::=
          *:* B
      +Closure:
        Vars: V
        Body::
          *:* S
          *:* B
    Env: E
Aspect::=
  *:* S

# Function application
-Application:
  Function:
    ClosureWithSavedEnv:
      Vars:=
      Body::=
        *:* S
  Arguments:=
+*:* S

K::
  -Closure: C
  +ClosureWithSavedEnv: C
  +RestoreEnvironment: E
Env: E

Threads:
  Thread:
    K::
      Application:
        Function:
          ClosureWithSavedEnv:
            Vars::
              -VarId: X
        Arguments::
          -Value: V
    Env:
      !Entry:
        VarId: X
      +Entry:
        VarId: X
        Location: L
Store:
  +Entry:
    Location: L
    Value: V
-NextLoc: L
+NextLoc: < L + 1

K::
  Application:
    Function:
      ClosureWithSavedEnv:
        Vars:
          VarId: X
Env:
  -Entry:
    VarId: X

# Tail call optimization
K::
  -RestoreEnvironment:
  RestoreEnvironment:

# Recursion
Threads:
  Thread:
    K::
      -MuConstructWithSavedEnv:
        !VarId:
        Body:
          *:* S
      +*:* S

K::
  -MuConstruct: M
  +MuConstructWithSavedEnv: M
  +RestoreEnvironment: E
Env: E

Threads:
  Thread:
    K::
      MuConstructWithSavedEnv:
        -VarId: X
        Body: B
    Env:
      !Entry:
        VarId: X
      +Entry:
        VarId: X
        Location: L
Store:
  +Entry:
    Location: L
    Value:
      Function:
        MuConstruct:
          VarId: X
          Body: B
-NextLoc: L
+NextLoc: < L + 1

K::
  MuConstructWithSavedEnv:
    VarId: X
Env:
  -Entry:
    VarId: X

# Call with current continuation (call/cc)
K::=
  -Callcc:
    LambdaAbstraction: L
  +Application:
    Function:
      LambdaAbstraction: L
    Arguments::
      Value:
        Function:
          Cc:
            Continuation::
              *:* K
            Env: E
  *:* K
Env: E

K::=
  -Application:
    Function:
      Cc:
        Continuation::
          *:* K
        Env: E
    Arguments::
      Value: V
  -*:*
  +Value: V
  +*:* K
-Env:
+Env: E

# Sequential Non-determinism
K::
  -RandomBool:
  +Value:
    Bool: true

K::
  -RandomBool:
  +Value:
    Bool: false

# Threads
Thread:
  K::
    -Spawn::=
      *:* S
  Env: E
+Thread:
  K::
    *:* S
  Env: E
  Holds:

-Thread:
  K::=
  Holds:=

Threads:
  Thread:
    K::=
    Holds:
      -Entry:
        Value: V
Busy:
  -Value: V

# Thread Synchronization
K::
  -Acquire:
    Value: V
Holds:
  Entry:
    Value: V
    Extras:
      +Extra:

Threads:
  Thread:
    K::
      -Acquire:
        Value: V
    Holds:
      +Entry:
        Value: V
        Extras:
Busy:
  !Value: V
  +Value: V

K::
  -Release:
    Value: V
Holds:
  Entry:
    Value: V
    Extras:
      -Extra:

Threads:
  Thread:
    K::
      -Release:
        Value: V
    Holds:
      -Entry:
        Value: V
        Extras:=
Busy:
  -Value: V

# Rendez-vous synchronization
Thread:
  K::
    -Rendezvous:
      Value: V
Thread:
  K::
    -Rendezvous:
      Value: V

# Agents
Agents:
  Agent:
    Threads:
      Thread:
        K::
          -NewAgent::
            *:* S
          +Value:
            Integer: N
    Me: M
  +Agent:
    Threads:
      Thread:
        K::
          *:* S
        Env:
        Holds:
    Busy:
    Me: N
    Parent: M
    Store:
    NextLoc: 0
    Aspect::
-NextAgent: N
+NextAgent: < N + 1

-Agent:
  Threads:=
